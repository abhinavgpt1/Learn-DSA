Knapsack memory optimization
----------------------------
In bottom-up approach, every [i][j] is filled with a row above [i-1][<someindex>]
SO, WE JUST REQUIRE A SINGLE VECTOR AS MEMORY OF LENGTH W = WEIGHT
Thus, reducing space complexity from O(n*W) to O(n).

Method: maintain 2 vectors prev and curr. Keep updating curr with values from prev
For i-> n:
	For j-> W:
	update curr using prev and some calculation
prev = curr
When inner loop ends, put prev = curr and continue the process.

NOTE: In most dp problems we require value from prev row or same row, hence space complexity can be reduced/
----------------------------------------------------------------------------------------------------------------

More optimization: Space O(W) - https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/#:~:text=Auxiliary%20Space%3A%20O(W)%20As%20we%20are%20using%20a%201%2DD%20array%20instead%20of%20a%202%2DD%20array

[WRONG] Reason: When we don't include the item, the dp[i][sum] value is copied from dp[i-1][sum] -> hence value doesn't change or in other terms, dp[i][sum] changes only when dp[i-1][sum-arr[i]] + val[i] > dp[i-1][sum]
Explained in 01Knapsack_DP(gfg_medium).cpp Solution1 with example

Above reason works for unbounded knapsack problem:- https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/

Space O(W) / O(sum) works only when inner loop in DP soln. works from W to 1 OR sum to 1, not other way round as future loops consider multiple instances of same element. Futhermore ans adds up / becomes true in case of knapsack / subsetsum problem
Reason why O(n) space isn't applicable for knapsack problems is that items are to be selected once and only once. A DP value can be inclusive of the item. Using this value for bigger evaluation doesn't consider whether the item was considered or not (Check EqualSumPartition(leetcode_medium))
"""
NOTE: IN CASE OF CONFUSION, USE 2 ARRAYS OF SIZE W/SUM AND CODE CONVENTIONALLY
"""